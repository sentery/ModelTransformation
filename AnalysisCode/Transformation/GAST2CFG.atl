-- @path CFG=/AnalysisCode/Metamodel/CFG.ecore
-- @path GAST=/AnalysisCode/Metamodel/gastm.ecore

module GAST2CFG;
create OUT : CFG from IN : GAST;


helper context GAST!BlockStatement def: getMap() : Map(GAST!Statement, GAST!Statement) =
	self.statements->iterate(e; acc: TupleType(
												prev: GAST!Statement,
												map: Map(GAST!Statement, GAST!Statement)
												) = Tuple{ prev = Sequence {}->first(), map = Map{}} |
	
				Tuple{
						prev = e,
						map =
								if acc.prev.oclIsUndefined() then
									acc.map
								else
									acc.map.including(acc.prev, e)
								endif
												}
).map;


helper def: next : Map(GAST!Statement, GAST!Statement) =
       GAST!BlockStatement.allInstances()->asSequence()->iterate(e; acc : Map(GAST!Statement, GAST!Statement) = Map {} |
               acc.union(e.getMap())
       );

helper context GAST!Statement def: next : GAST!Statement =
	thisModule.next.get(self);




abstract rule Statement2Node {
	from
		s : GAST!Statement( not s.oclIsKindOf(GAST!BlockStatement))
	to 
		t : CFG!AbstractNode (
			--expression <- thisModule.Expression
			var <- s.accesses->select(e | e.oclIsKindOf(GAST!VariableAccess))->collect(c | c.accessedTarget)->select(e2| e2.oclIsKindOf(GAST!LocalVariable))
		)
}

lazy abstract rule Expression {
	from
		s : GAST!GASTExpression
	to 
		t : CFG!Expression (
			
		)
}

rule createMCFG {
	from
		s : GAST!Method(not s.body.oclIsUndefined())
	to 
		t : CFG!MControlFlowGraph (
			name <- s.simpleName+''+s.formalParameters.toString()
			,
--			nodes <- GAST!Statement.allInstances()
--			
--			,
			nodes <- if not s.body.oclIsUndefined() then
						s.body.statements
					else s.body
					endif,
			localVar <- s.localVariables
		)
}

rule LoopStatement extends Statement2Node  {
	from
		s : GAST!LoopStatement
	to 
		t : CFG!IterativeNode (
			trueConditionNode <- s.body.statements.first(),
			falseConditionNode <- s.next,
			name <- s.kind.toString(),
			nodes <-  s.body.statements
			
			
		)
}

rule SimpleStatement extends Statement2Node {
	from
		s : GAST!SimpleStatement
	to 
		t : CFG!Node (
			toNode <-  if s.oclIsUndefined() then 
							s.refImmediateComposite().refImmediateComposite()
						else
							s.next
						endif
		)
}


rule jumpStatement extends Statement2Node {
	from
		s : GAST!JumpStatement
	to 
		t : CFG!Node (
			toNode <- if s.oclIsUndefined() then 
						s.refImmediateComposite().refImmediateComposite()
						else
							s.next
						endif
		)
}

rule BranchStatement  extends Statement2Node{
	from
		s : GAST!BranchStatement
	to 
		t : CFG!ConditionalNode (
--			trueConditionNode <- s.branches->collect(c | c.statement.next)
			trueConditionNode <-s.branches.first(),
			falseConditionNode <-  s.branches.last()
			
			
		)
		

}

 rule Brannch {
	from
		s : GAST!Branch
	to 
		t : CFG!Node (
			toNode <- if s.oclIsUndefined() then 
						s.refImmediateComposite().refImmediateComposite()
						else
							s.statement.next
						endif
		)
}


 rule LocalVariable2Var {
	from
		s : GAST!LocalVariable
	to 
		t : CFG!Var (
			name <- s.simpleName
		)
}


--rule ExpressionStatement  extends Statement2Node {
--	from
--		s : GAST!GASTExpression
--	to 
--		t : CFG!ConditionalNode (
--			toNode <- s.annotations.
--		)
--}
