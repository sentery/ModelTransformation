-- @path GPH=/TestTransformation/Metamodel/extendsecore.ecore
-- @path GAST=/TestTransformation/Metamodel/gastm.ecore

module GAST2Graph;
create OUT : GPH from IN : GAST;


helper context GAST!Method def: isMethodRoot : Boolean =
	self.refImmediateComposite().oclIsUndefined();

helper def: getCFnext(s: GAST!Statement,arr:Sequence(GAST!Statement)): GAST!Statement =

	let rs : GAST!Statement = s in
			if arr.size() > 0 then 
				if arr.size() > 1 and arr.indexOf(rs) < arr.size() then 
				
					
					 arr.at(arr.indexOf(rs)+1).debug()
				else
					Sequence{}
				endif
				 
			 else
			 	Sequence{}
			 endif
			
;


--helper context GAST!Method def : getAllStatement (): Sequence(GAST!Statement) = 
--	
--	if(self.body.oclIsUndefined()) then 
--		Sequence{}
--	else 
--		self.body.statements
--	endif;
helper context GAST!Method def : getAllStatement (): Sequence(GAST!Statement) = 
	
	if(self.body.oclIsUndefined()) then 
		Sequence{}
	else 
		let arrStm :  Sequence(GAST!Statement) = self.body.statements
		in
			if arrStm.isEmpty() then 
				Sequence{}
			else 
				arrStm->collect(c | c.cfNext = thisModule.getCFnext(c, self.body.statements))->
				iterate(e; ret: Sequence(GAST!Statement) = Sequence{} | 
				
					if e.oclIsKindOf(GAST!SimpleStatement) then
					ret -> including(e)
				else
					if e.oclIsKindOf(GAST!LoopStatement) then
--						if e.kind = #pk_initial then
--							ret -> including(e)
--						else
--							ret -> including(e.getPredecessors())
--						endif
						ret -> including(e)
					else
						ret
					endif
				endif
				
				)
			endif
--		->collect(c |  arrSrm -> including(c.cfNext(thisModule.getCFnext(c, self.body.statements))))
	endif;

helper context GAST!Method def : transfromStatementByCondition(s :GAST!Statement): OclAny =
	if s.oclIsTypeOf(GAST!SimpleStatement) then 
		thisModule.TransformStatement(s)
	else
		if s.oclIsTypeOf(GAST!JumpStatement) then 
			thisModule.TransformJumpStatement(s)
			
		else
			false
	endif
	endif
	
	;

	
	

--helper context GAST!VariableAccess def : getAllStatement (): OrderedSet(GAST!Statement) = 
--	
--	self.allStatements->iterate(child; elements: OrderedSet(GAST!Statement) = 
--		OrderedSet{} |
--		if child.oclIsTypeOf(GAST!Statement) then
--			elements.append(child)
--		else
--			elements.append(child)
--		endif

--self.children->iterate(child; elements: OrderedSet(MM!TreeElement) = 
--		OrderedSet{} |
--		if child.oclIsTypeOf(MM!Node) then
--			elements.union(child.getAllChildren())
--			
--		else
--			elements.append(child)
--		endif
--);


rule TransformMethod {
	from
		s : GAST!Method
		
	
	to 
		t : GPH!Method (
--			statements  <-   s.id,
			simpleName <- s.simpleName,
			statements  <-   s.getAllStatement()->collect(c |
				if c.oclIsTypeOf(GAST!SimpleStatement) then 
					thisModule.TransformSimplaeStatement(c)
					
				else
					if c.oclIsTypeOf(GAST!JumpStatement) then
						thisModule.TransformJumpStatement(c)
					else
--						thisModule.TransformLoopStatement(c)
						thisModule.TransformLoopStatement(c)
					endif
				endif
				
--				if c.oclIsTypeOf(GAST!SimpleStatement) then 
--					thisModule.TransformSimplaeStatement(c)
--				else if c.oclIsTypeOf(GAST!JumpStatement) then 
--					thisModule.TransformJumpStatement(c)
--				else
--					thisModule.TransformLoopStatement(c)
--			endif	
		)
		
)	

}
--rule TransformMethod {
--	from
--		s : GAST!Method
--	to 
--		t : GPH!Method (
--			simpleName <- s.simpleName,
--			allStatements <- if s.body.oclIsTypeOf(GAST!BlockStatement) then 
--									
--								s.body.statements->asSequence()->collect(c | 
--									c.accesses.asSequence()->collect(a | 
--										
--										if a.oclIsTypeOf(GAST!VariableAccess) then
--												a.oclType().debug()
--										else
--											a.oclType().debug()
--										endif
--									
--									)
--									
--								)
--							else
--								thisModule.getAllStatement.debug()
--							endif
--						
--		)
--	
--	
--}






-- lazy rule TransformStatement {
--	from
--		s : GAST!Statement
--	to 
--		t : GPH!Statement (
--			id <- s.id,
--			
--			
--			
--		)
--}
 
  lazy rule TransformSimplaeStatement {
	from
		s : GAST!SimpleStatement
	to 
		t : GPH!SimpleStatement (
			id <- s.id,
			accesses <- s.accesses->collect(c |
				
			if c.oclIsTypeOf(GAST!VariableAccess) then 
				thisModule.TransfromValiableAccess(c)
			else
				thisModule.TransfromSelfAccess(c)
			endif
			)
			, cfNext <- s.cfNext.debug()
			
			
		)
}
 

lazy  rule TransformJumpStatement {
	from
		s : GAST!JumpStatement
	to 
		t : GPH!JumpStatement (
			id <- s.id
		)
}

lazy rule TransformLoopStatement {
	from
		s : GAST!LoopStatement
	to 
		t : GPH!LoopStatement(
			statements <- s.body.statements->asSequence()->collect(c | 
				
				if c.oclIsTypeOf(GAST!SimpleStatement) then 
					thisModule.TransformSimplaeStatement(c)
					
				else
					if c.oclIsTypeOf(GAST!JumpStatement) then
						thisModule.TransformJumpStatement(c)
					else
						thisModule.TransformBranchStatement(c)
					endif
				endif
				
			
			
			)
			)
 }


lazy  rule TransformBranchStatement {
	from
		s : GAST!BranchStatement
	to 
		t : GPH!If (
			thens <- s.branches->collect(c | 
				
			if c.statement.oclIsTypeOf(GAST!SimpleStatement) then 
					thisModule.TransformSimplaeStatement(c.statement)
					
				else
					if c.statement.oclIsTypeOf(GAST!JumpStatement) then
						thisModule.TransformJumpStatement(c.statement)
					else
						thisModule.TransformSimplaeStatement(c.statement)
--						thisModule.TransformBranchStatement(c.statement)
					endif
				endif
			)
			
			
			
			,
			elses <- if not s.branch.oclIsUndefined() then
						s.branch.oclType().debug()
					else
						Sequence {}
					endif
		)
}

--rule TransfromBlockStatement {
--	from
--		s : GAST!BlockStatement
--	to 
--		t : GPH!Block (
--			statement <- s.statements->collect(c | 
--			
--			if c.oclIsTypeOf(GAST!SimpleStatement) then 
--					thisModule.TransformStatement(c)
--					
--				else
--					if c.oclIsTypeOf(GAST!JumpStatement) then
--						thisModule.TransformJumpStatement(c)
--					else
----						thisModule.TransformLoopStatement(c)
--OrderedSet{}
--					endif
--				endif
--			
--		)
--		)
--}


 lazy rule TransfromValiableAccess {
	from
		s : GAST!VariableAccess
	to 
		t : GPH!VariableAccess (
		
--			id <- s.accessedTarget.oclType().debug()
		)
}
 
 lazy rule TransfromSelfAccess {
	from
		s : GAST!SelfAccess
	to 
		t : GPH!SelfAccess (
			
		)
}


 lazy rule TransfromLocalValiable {
	from
		s : GAST!LocalVariable
	to 
		t : GPH!LocalVariable (
			simpleName <- s.simpleName.debug()
		)
}
